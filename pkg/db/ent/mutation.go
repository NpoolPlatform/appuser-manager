// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/app"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appcontrol"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/approle"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appuser"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appuserextra"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appusersecret"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/banapp"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/banappuser"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/predicate"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp           = "App"
	TypeAppControl    = "AppControl"
	TypeAppRole       = "AppRole"
	TypeAppUser       = "AppUser"
	TypeAppUserExtra  = "AppUserExtra"
	TypeAppUserSecret = "AppUserSecret"
	TypeBanApp        = "BanApp"
	TypeBanAppUser    = "BanAppUser"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_by    *uuid.UUID
	name          *string
	logo          *string
	description   *string
	create_at     *uint32
	addcreate_at  *int32
	update_at     *uint32
	addupdate_at  *int32
	delete_at     *uint32
	adddelete_at  *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*App, error)
	predicates    []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id uuid.UUID) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetLogo sets the "logo" field.
func (m *AppMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *AppMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ResetLogo resets all changes to the "logo" field.
func (m *AppMutation) ResetLogo() {
	m.logo = nil
}

// SetDescription sets the "description" field.
func (m *AppMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AppMutation) ResetDescription() {
	m.description = nil
}

// SetCreateAt sets the "create_at" field.
func (m *AppMutation) SetCreateAt(u uint32) {
	m.create_at = &u
	m.addcreate_at = nil
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *AppMutation) CreateAt() (r uint32, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds u to the "create_at" field.
func (m *AppMutation) AddCreateAt(u int32) {
	if m.addcreate_at != nil {
		*m.addcreate_at += u
	} else {
		m.addcreate_at = &u
	}
}

// AddedCreateAt returns the value that was added to the "create_at" field in this mutation.
func (m *AppMutation) AddedCreateAt() (r int32, exists bool) {
	v := m.addcreate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *AppMutation) ResetCreateAt() {
	m.create_at = nil
	m.addcreate_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *AppMutation) SetUpdateAt(u uint32) {
	m.update_at = &u
	m.addupdate_at = nil
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *AppMutation) UpdateAt() (r uint32, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds u to the "update_at" field.
func (m *AppMutation) AddUpdateAt(u int32) {
	if m.addupdate_at != nil {
		*m.addupdate_at += u
	} else {
		m.addupdate_at = &u
	}
}

// AddedUpdateAt returns the value that was added to the "update_at" field in this mutation.
func (m *AppMutation) AddedUpdateAt() (r int32, exists bool) {
	v := m.addupdate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *AppMutation) ResetUpdateAt() {
	m.update_at = nil
	m.addupdate_at = nil
}

// SetDeleteAt sets the "delete_at" field.
func (m *AppMutation) SetDeleteAt(u uint32) {
	m.delete_at = &u
	m.adddelete_at = nil
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *AppMutation) DeleteAt() (r uint32, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDeleteAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// AddDeleteAt adds u to the "delete_at" field.
func (m *AppMutation) AddDeleteAt(u int32) {
	if m.adddelete_at != nil {
		*m.adddelete_at += u
	} else {
		m.adddelete_at = &u
	}
}

// AddedDeleteAt returns the value that was added to the "delete_at" field in this mutation.
func (m *AppMutation) AddedDeleteAt() (r int32, exists bool) {
	v := m.adddelete_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *AppMutation) ResetDeleteAt() {
	m.delete_at = nil
	m.adddelete_at = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, app.FieldCreatedBy)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.logo != nil {
		fields = append(fields, app.FieldLogo)
	}
	if m.description != nil {
		fields = append(fields, app.FieldDescription)
	}
	if m.create_at != nil {
		fields = append(fields, app.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, app.FieldUpdateAt)
	}
	if m.delete_at != nil {
		fields = append(fields, app.FieldDeleteAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedBy:
		return m.CreatedBy()
	case app.FieldName:
		return m.Name()
	case app.FieldLogo:
		return m.Logo()
	case app.FieldDescription:
		return m.Description()
	case app.FieldCreateAt:
		return m.CreateAt()
	case app.FieldUpdateAt:
		return m.UpdateAt()
	case app.FieldDeleteAt:
		return m.DeleteAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldLogo:
		return m.OldLogo(ctx)
	case app.FieldDescription:
		return m.OldDescription(ctx)
	case app.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case app.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case app.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case app.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case app.FieldCreateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case app.FieldUpdateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case app.FieldDeleteAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_at != nil {
		fields = append(fields, app.FieldCreateAt)
	}
	if m.addupdate_at != nil {
		fields = append(fields, app.FieldUpdateAt)
	}
	if m.adddelete_at != nil {
		fields = append(fields, app.FieldDeleteAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreateAt:
		return m.AddedCreateAt()
	case app.FieldUpdateAt:
		return m.AddedUpdateAt()
	case app.FieldDeleteAt:
		return m.AddedDeleteAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case app.FieldUpdateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	case app.FieldDeleteAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldLogo:
		m.ResetLogo()
		return nil
	case app.FieldDescription:
		m.ResetDescription()
		return nil
	case app.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case app.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case app.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown App edge %s", name)
}

// AppControlMutation represents an operation that mutates the AppControl nodes in the graph.
type AppControlMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	app_id                *uuid.UUID
	signup_methods        *[]string
	extern_signin_methods *[]string
	recaptcha_method      *string
	kyc_enable            *bool
	signin_verify_enable  *bool
	create_at             *uint32
	addcreate_at          *int32
	update_at             *uint32
	addupdate_at          *int32
	delete_at             *uint32
	adddelete_at          *int32
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*AppControl, error)
	predicates            []predicate.AppControl
}

var _ ent.Mutation = (*AppControlMutation)(nil)

// appcontrolOption allows management of the mutation configuration using functional options.
type appcontrolOption func(*AppControlMutation)

// newAppControlMutation creates new mutation for the AppControl entity.
func newAppControlMutation(c config, op Op, opts ...appcontrolOption) *AppControlMutation {
	m := &AppControlMutation{
		config:        c,
		op:            op,
		typ:           TypeAppControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppControlID sets the ID field of the mutation.
func withAppControlID(id uuid.UUID) appcontrolOption {
	return func(m *AppControlMutation) {
		var (
			err   error
			once  sync.Once
			value *AppControl
		)
		m.oldValue = func(ctx context.Context) (*AppControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppControl sets the old AppControl of the mutation.
func withAppControl(node *AppControl) appcontrolOption {
	return func(m *AppControlMutation) {
		m.oldValue = func(context.Context) (*AppControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppControl entities.
func (m *AppControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *AppControlMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppControlMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppControlMutation) ResetAppID() {
	m.app_id = nil
}

// SetSignupMethods sets the "signup_methods" field.
func (m *AppControlMutation) SetSignupMethods(s []string) {
	m.signup_methods = &s
}

// SignupMethods returns the value of the "signup_methods" field in the mutation.
func (m *AppControlMutation) SignupMethods() (r []string, exists bool) {
	v := m.signup_methods
	if v == nil {
		return
	}
	return *v, true
}

// OldSignupMethods returns the old "signup_methods" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldSignupMethods(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignupMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignupMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignupMethods: %w", err)
	}
	return oldValue.SignupMethods, nil
}

// ResetSignupMethods resets all changes to the "signup_methods" field.
func (m *AppControlMutation) ResetSignupMethods() {
	m.signup_methods = nil
}

// SetExternSigninMethods sets the "extern_signin_methods" field.
func (m *AppControlMutation) SetExternSigninMethods(s []string) {
	m.extern_signin_methods = &s
}

// ExternSigninMethods returns the value of the "extern_signin_methods" field in the mutation.
func (m *AppControlMutation) ExternSigninMethods() (r []string, exists bool) {
	v := m.extern_signin_methods
	if v == nil {
		return
	}
	return *v, true
}

// OldExternSigninMethods returns the old "extern_signin_methods" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldExternSigninMethods(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternSigninMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternSigninMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternSigninMethods: %w", err)
	}
	return oldValue.ExternSigninMethods, nil
}

// ResetExternSigninMethods resets all changes to the "extern_signin_methods" field.
func (m *AppControlMutation) ResetExternSigninMethods() {
	m.extern_signin_methods = nil
}

// SetRecaptchaMethod sets the "recaptcha_method" field.
func (m *AppControlMutation) SetRecaptchaMethod(s string) {
	m.recaptcha_method = &s
}

// RecaptchaMethod returns the value of the "recaptcha_method" field in the mutation.
func (m *AppControlMutation) RecaptchaMethod() (r string, exists bool) {
	v := m.recaptcha_method
	if v == nil {
		return
	}
	return *v, true
}

// OldRecaptchaMethod returns the old "recaptcha_method" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldRecaptchaMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecaptchaMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecaptchaMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecaptchaMethod: %w", err)
	}
	return oldValue.RecaptchaMethod, nil
}

// ResetRecaptchaMethod resets all changes to the "recaptcha_method" field.
func (m *AppControlMutation) ResetRecaptchaMethod() {
	m.recaptcha_method = nil
}

// SetKycEnable sets the "kyc_enable" field.
func (m *AppControlMutation) SetKycEnable(b bool) {
	m.kyc_enable = &b
}

// KycEnable returns the value of the "kyc_enable" field in the mutation.
func (m *AppControlMutation) KycEnable() (r bool, exists bool) {
	v := m.kyc_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldKycEnable returns the old "kyc_enable" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldKycEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKycEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKycEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKycEnable: %w", err)
	}
	return oldValue.KycEnable, nil
}

// ResetKycEnable resets all changes to the "kyc_enable" field.
func (m *AppControlMutation) ResetKycEnable() {
	m.kyc_enable = nil
}

// SetSigninVerifyEnable sets the "signin_verify_enable" field.
func (m *AppControlMutation) SetSigninVerifyEnable(b bool) {
	m.signin_verify_enable = &b
}

// SigninVerifyEnable returns the value of the "signin_verify_enable" field in the mutation.
func (m *AppControlMutation) SigninVerifyEnable() (r bool, exists bool) {
	v := m.signin_verify_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldSigninVerifyEnable returns the old "signin_verify_enable" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldSigninVerifyEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigninVerifyEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigninVerifyEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigninVerifyEnable: %w", err)
	}
	return oldValue.SigninVerifyEnable, nil
}

// ResetSigninVerifyEnable resets all changes to the "signin_verify_enable" field.
func (m *AppControlMutation) ResetSigninVerifyEnable() {
	m.signin_verify_enable = nil
}

// SetCreateAt sets the "create_at" field.
func (m *AppControlMutation) SetCreateAt(u uint32) {
	m.create_at = &u
	m.addcreate_at = nil
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *AppControlMutation) CreateAt() (r uint32, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldCreateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds u to the "create_at" field.
func (m *AppControlMutation) AddCreateAt(u int32) {
	if m.addcreate_at != nil {
		*m.addcreate_at += u
	} else {
		m.addcreate_at = &u
	}
}

// AddedCreateAt returns the value that was added to the "create_at" field in this mutation.
func (m *AppControlMutation) AddedCreateAt() (r int32, exists bool) {
	v := m.addcreate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *AppControlMutation) ResetCreateAt() {
	m.create_at = nil
	m.addcreate_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *AppControlMutation) SetUpdateAt(u uint32) {
	m.update_at = &u
	m.addupdate_at = nil
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *AppControlMutation) UpdateAt() (r uint32, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldUpdateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds u to the "update_at" field.
func (m *AppControlMutation) AddUpdateAt(u int32) {
	if m.addupdate_at != nil {
		*m.addupdate_at += u
	} else {
		m.addupdate_at = &u
	}
}

// AddedUpdateAt returns the value that was added to the "update_at" field in this mutation.
func (m *AppControlMutation) AddedUpdateAt() (r int32, exists bool) {
	v := m.addupdate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *AppControlMutation) ResetUpdateAt() {
	m.update_at = nil
	m.addupdate_at = nil
}

// SetDeleteAt sets the "delete_at" field.
func (m *AppControlMutation) SetDeleteAt(u uint32) {
	m.delete_at = &u
	m.adddelete_at = nil
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *AppControlMutation) DeleteAt() (r uint32, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldDeleteAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// AddDeleteAt adds u to the "delete_at" field.
func (m *AppControlMutation) AddDeleteAt(u int32) {
	if m.adddelete_at != nil {
		*m.adddelete_at += u
	} else {
		m.adddelete_at = &u
	}
}

// AddedDeleteAt returns the value that was added to the "delete_at" field in this mutation.
func (m *AppControlMutation) AddedDeleteAt() (r int32, exists bool) {
	v := m.adddelete_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *AppControlMutation) ResetDeleteAt() {
	m.delete_at = nil
	m.adddelete_at = nil
}

// Where appends a list predicates to the AppControlMutation builder.
func (m *AppControlMutation) Where(ps ...predicate.AppControl) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppControlMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppControl).
func (m *AppControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppControlMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.app_id != nil {
		fields = append(fields, appcontrol.FieldAppID)
	}
	if m.signup_methods != nil {
		fields = append(fields, appcontrol.FieldSignupMethods)
	}
	if m.extern_signin_methods != nil {
		fields = append(fields, appcontrol.FieldExternSigninMethods)
	}
	if m.recaptcha_method != nil {
		fields = append(fields, appcontrol.FieldRecaptchaMethod)
	}
	if m.kyc_enable != nil {
		fields = append(fields, appcontrol.FieldKycEnable)
	}
	if m.signin_verify_enable != nil {
		fields = append(fields, appcontrol.FieldSigninVerifyEnable)
	}
	if m.create_at != nil {
		fields = append(fields, appcontrol.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, appcontrol.FieldUpdateAt)
	}
	if m.delete_at != nil {
		fields = append(fields, appcontrol.FieldDeleteAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appcontrol.FieldAppID:
		return m.AppID()
	case appcontrol.FieldSignupMethods:
		return m.SignupMethods()
	case appcontrol.FieldExternSigninMethods:
		return m.ExternSigninMethods()
	case appcontrol.FieldRecaptchaMethod:
		return m.RecaptchaMethod()
	case appcontrol.FieldKycEnable:
		return m.KycEnable()
	case appcontrol.FieldSigninVerifyEnable:
		return m.SigninVerifyEnable()
	case appcontrol.FieldCreateAt:
		return m.CreateAt()
	case appcontrol.FieldUpdateAt:
		return m.UpdateAt()
	case appcontrol.FieldDeleteAt:
		return m.DeleteAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appcontrol.FieldAppID:
		return m.OldAppID(ctx)
	case appcontrol.FieldSignupMethods:
		return m.OldSignupMethods(ctx)
	case appcontrol.FieldExternSigninMethods:
		return m.OldExternSigninMethods(ctx)
	case appcontrol.FieldRecaptchaMethod:
		return m.OldRecaptchaMethod(ctx)
	case appcontrol.FieldKycEnable:
		return m.OldKycEnable(ctx)
	case appcontrol.FieldSigninVerifyEnable:
		return m.OldSigninVerifyEnable(ctx)
	case appcontrol.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case appcontrol.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case appcontrol.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appcontrol.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appcontrol.FieldSignupMethods:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignupMethods(v)
		return nil
	case appcontrol.FieldExternSigninMethods:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternSigninMethods(v)
		return nil
	case appcontrol.FieldRecaptchaMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecaptchaMethod(v)
		return nil
	case appcontrol.FieldKycEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKycEnable(v)
		return nil
	case appcontrol.FieldSigninVerifyEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigninVerifyEnable(v)
		return nil
	case appcontrol.FieldCreateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case appcontrol.FieldUpdateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case appcontrol.FieldDeleteAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppControlMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_at != nil {
		fields = append(fields, appcontrol.FieldCreateAt)
	}
	if m.addupdate_at != nil {
		fields = append(fields, appcontrol.FieldUpdateAt)
	}
	if m.adddelete_at != nil {
		fields = append(fields, appcontrol.FieldDeleteAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appcontrol.FieldCreateAt:
		return m.AddedCreateAt()
	case appcontrol.FieldUpdateAt:
		return m.AddedUpdateAt()
	case appcontrol.FieldDeleteAt:
		return m.AddedDeleteAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appcontrol.FieldCreateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case appcontrol.FieldUpdateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	case appcontrol.FieldDeleteAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppControlMutation) ResetField(name string) error {
	switch name {
	case appcontrol.FieldAppID:
		m.ResetAppID()
		return nil
	case appcontrol.FieldSignupMethods:
		m.ResetSignupMethods()
		return nil
	case appcontrol.FieldExternSigninMethods:
		m.ResetExternSigninMethods()
		return nil
	case appcontrol.FieldRecaptchaMethod:
		m.ResetRecaptchaMethod()
		return nil
	case appcontrol.FieldKycEnable:
		m.ResetKycEnable()
		return nil
	case appcontrol.FieldSigninVerifyEnable:
		m.ResetSigninVerifyEnable()
		return nil
	case appcontrol.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case appcontrol.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case appcontrol.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	}
	return fmt.Errorf("unknown AppControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppControlMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppControlMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppControlMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppControlMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppControl edge %s", name)
}

// AppRoleMutation represents an operation that mutates the AppRole nodes in the graph.
type AppRoleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_by    *uuid.UUID
	role          *string
	description   *string
	app_id        *uuid.UUID
	_default      *bool
	create_at     *uint32
	addcreate_at  *int32
	update_at     *uint32
	addupdate_at  *int32
	delete_at     *uint32
	adddelete_at  *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppRole, error)
	predicates    []predicate.AppRole
}

var _ ent.Mutation = (*AppRoleMutation)(nil)

// approleOption allows management of the mutation configuration using functional options.
type approleOption func(*AppRoleMutation)

// newAppRoleMutation creates new mutation for the AppRole entity.
func newAppRoleMutation(c config, op Op, opts ...approleOption) *AppRoleMutation {
	m := &AppRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppRoleID sets the ID field of the mutation.
func withAppRoleID(id uuid.UUID) approleOption {
	return func(m *AppRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRole
		)
		m.oldValue = func(ctx context.Context) (*AppRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRole sets the old AppRole of the mutation.
func withAppRole(node *AppRole) approleOption {
	return func(m *AppRoleMutation) {
		m.oldValue = func(context.Context) (*AppRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRole entities.
func (m *AppRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppRoleMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppRoleMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppRoleMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetRole sets the "role" field.
func (m *AppRoleMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *AppRoleMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *AppRoleMutation) ResetRole() {
	m.role = nil
}

// SetDescription sets the "description" field.
func (m *AppRoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppRoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AppRoleMutation) ResetDescription() {
	m.description = nil
}

// SetAppID sets the "app_id" field.
func (m *AppRoleMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppRoleMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppRoleMutation) ResetAppID() {
	m.app_id = nil
}

// SetDefault sets the "default" field.
func (m *AppRoleMutation) SetDefault(b bool) {
	m._default = &b
}

// Default returns the value of the "default" field in the mutation.
func (m *AppRoleMutation) Default() (r bool, exists bool) {
	v := m._default
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault returns the old "default" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault: %w", err)
	}
	return oldValue.Default, nil
}

// ResetDefault resets all changes to the "default" field.
func (m *AppRoleMutation) ResetDefault() {
	m._default = nil
}

// SetCreateAt sets the "create_at" field.
func (m *AppRoleMutation) SetCreateAt(u uint32) {
	m.create_at = &u
	m.addcreate_at = nil
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *AppRoleMutation) CreateAt() (r uint32, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldCreateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds u to the "create_at" field.
func (m *AppRoleMutation) AddCreateAt(u int32) {
	if m.addcreate_at != nil {
		*m.addcreate_at += u
	} else {
		m.addcreate_at = &u
	}
}

// AddedCreateAt returns the value that was added to the "create_at" field in this mutation.
func (m *AppRoleMutation) AddedCreateAt() (r int32, exists bool) {
	v := m.addcreate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *AppRoleMutation) ResetCreateAt() {
	m.create_at = nil
	m.addcreate_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *AppRoleMutation) SetUpdateAt(u uint32) {
	m.update_at = &u
	m.addupdate_at = nil
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *AppRoleMutation) UpdateAt() (r uint32, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldUpdateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds u to the "update_at" field.
func (m *AppRoleMutation) AddUpdateAt(u int32) {
	if m.addupdate_at != nil {
		*m.addupdate_at += u
	} else {
		m.addupdate_at = &u
	}
}

// AddedUpdateAt returns the value that was added to the "update_at" field in this mutation.
func (m *AppRoleMutation) AddedUpdateAt() (r int32, exists bool) {
	v := m.addupdate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *AppRoleMutation) ResetUpdateAt() {
	m.update_at = nil
	m.addupdate_at = nil
}

// SetDeleteAt sets the "delete_at" field.
func (m *AppRoleMutation) SetDeleteAt(u uint32) {
	m.delete_at = &u
	m.adddelete_at = nil
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *AppRoleMutation) DeleteAt() (r uint32, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldDeleteAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// AddDeleteAt adds u to the "delete_at" field.
func (m *AppRoleMutation) AddDeleteAt(u int32) {
	if m.adddelete_at != nil {
		*m.adddelete_at += u
	} else {
		m.adddelete_at = &u
	}
}

// AddedDeleteAt returns the value that was added to the "delete_at" field in this mutation.
func (m *AppRoleMutation) AddedDeleteAt() (r int32, exists bool) {
	v := m.adddelete_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *AppRoleMutation) ResetDeleteAt() {
	m.delete_at = nil
	m.adddelete_at = nil
}

// Where appends a list predicates to the AppRoleMutation builder.
func (m *AppRoleMutation) Where(ps ...predicate.AppRole) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppRole).
func (m *AppRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppRoleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, approle.FieldCreatedBy)
	}
	if m.role != nil {
		fields = append(fields, approle.FieldRole)
	}
	if m.description != nil {
		fields = append(fields, approle.FieldDescription)
	}
	if m.app_id != nil {
		fields = append(fields, approle.FieldAppID)
	}
	if m._default != nil {
		fields = append(fields, approle.FieldDefault)
	}
	if m.create_at != nil {
		fields = append(fields, approle.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, approle.FieldUpdateAt)
	}
	if m.delete_at != nil {
		fields = append(fields, approle.FieldDeleteAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approle.FieldCreatedBy:
		return m.CreatedBy()
	case approle.FieldRole:
		return m.Role()
	case approle.FieldDescription:
		return m.Description()
	case approle.FieldAppID:
		return m.AppID()
	case approle.FieldDefault:
		return m.Default()
	case approle.FieldCreateAt:
		return m.CreateAt()
	case approle.FieldUpdateAt:
		return m.UpdateAt()
	case approle.FieldDeleteAt:
		return m.DeleteAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approle.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case approle.FieldRole:
		return m.OldRole(ctx)
	case approle.FieldDescription:
		return m.OldDescription(ctx)
	case approle.FieldAppID:
		return m.OldAppID(ctx)
	case approle.FieldDefault:
		return m.OldDefault(ctx)
	case approle.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case approle.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case approle.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approle.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case approle.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case approle.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case approle.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case approle.FieldDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault(v)
		return nil
	case approle.FieldCreateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case approle.FieldUpdateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case approle.FieldDeleteAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppRoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_at != nil {
		fields = append(fields, approle.FieldCreateAt)
	}
	if m.addupdate_at != nil {
		fields = append(fields, approle.FieldUpdateAt)
	}
	if m.adddelete_at != nil {
		fields = append(fields, approle.FieldDeleteAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case approle.FieldCreateAt:
		return m.AddedCreateAt()
	case approle.FieldUpdateAt:
		return m.AddedUpdateAt()
	case approle.FieldDeleteAt:
		return m.AddedDeleteAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case approle.FieldCreateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case approle.FieldUpdateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	case approle.FieldDeleteAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppRoleMutation) ResetField(name string) error {
	switch name {
	case approle.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case approle.FieldRole:
		m.ResetRole()
		return nil
	case approle.FieldDescription:
		m.ResetDescription()
		return nil
	case approle.FieldAppID:
		m.ResetAppID()
		return nil
	case approle.FieldDefault:
		m.ResetDefault()
		return nil
	case approle.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case approle.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case approle.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	}
	return fmt.Errorf("unknown AppRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppRole edge %s", name)
}

// AppUserMutation represents an operation that mutates the AppUser nodes in the graph.
type AppUserMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	app_id          *uuid.UUID
	email_address   *string
	phone_no        *string
	import_from_app *uuid.UUID
	create_at       *uint32
	addcreate_at    *int32
	update_at       *uint32
	addupdate_at    *int32
	delete_at       *uint32
	adddelete_at    *int32
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*AppUser, error)
	predicates      []predicate.AppUser
}

var _ ent.Mutation = (*AppUserMutation)(nil)

// appuserOption allows management of the mutation configuration using functional options.
type appuserOption func(*AppUserMutation)

// newAppUserMutation creates new mutation for the AppUser entity.
func newAppUserMutation(c config, op Op, opts ...appuserOption) *AppUserMutation {
	m := &AppUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserID sets the ID field of the mutation.
func withAppUserID(id uuid.UUID) appuserOption {
	return func(m *AppUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUser
		)
		m.oldValue = func(ctx context.Context) (*AppUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUser sets the old AppUser of the mutation.
func withAppUser(node *AppUser) appuserOption {
	return func(m *AppUserMutation) {
		m.oldValue = func(context.Context) (*AppUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUser entities.
func (m *AppUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *AppUserMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserMutation) ResetAppID() {
	m.app_id = nil
}

// SetEmailAddress sets the "email_address" field.
func (m *AppUserMutation) SetEmailAddress(s string) {
	m.email_address = &s
}

// EmailAddress returns the value of the "email_address" field in the mutation.
func (m *AppUserMutation) EmailAddress() (r string, exists bool) {
	v := m.email_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailAddress returns the old "email_address" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldEmailAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailAddress: %w", err)
	}
	return oldValue.EmailAddress, nil
}

// ResetEmailAddress resets all changes to the "email_address" field.
func (m *AppUserMutation) ResetEmailAddress() {
	m.email_address = nil
}

// SetPhoneNo sets the "phone_no" field.
func (m *AppUserMutation) SetPhoneNo(s string) {
	m.phone_no = &s
}

// PhoneNo returns the value of the "phone_no" field in the mutation.
func (m *AppUserMutation) PhoneNo() (r string, exists bool) {
	v := m.phone_no
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNo returns the old "phone_no" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldPhoneNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNo: %w", err)
	}
	return oldValue.PhoneNo, nil
}

// ResetPhoneNo resets all changes to the "phone_no" field.
func (m *AppUserMutation) ResetPhoneNo() {
	m.phone_no = nil
}

// SetImportFromApp sets the "import_from_app" field.
func (m *AppUserMutation) SetImportFromApp(u uuid.UUID) {
	m.import_from_app = &u
}

// ImportFromApp returns the value of the "import_from_app" field in the mutation.
func (m *AppUserMutation) ImportFromApp() (r uuid.UUID, exists bool) {
	v := m.import_from_app
	if v == nil {
		return
	}
	return *v, true
}

// OldImportFromApp returns the old "import_from_app" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldImportFromApp(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportFromApp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportFromApp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportFromApp: %w", err)
	}
	return oldValue.ImportFromApp, nil
}

// ResetImportFromApp resets all changes to the "import_from_app" field.
func (m *AppUserMutation) ResetImportFromApp() {
	m.import_from_app = nil
}

// SetCreateAt sets the "create_at" field.
func (m *AppUserMutation) SetCreateAt(u uint32) {
	m.create_at = &u
	m.addcreate_at = nil
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *AppUserMutation) CreateAt() (r uint32, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldCreateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds u to the "create_at" field.
func (m *AppUserMutation) AddCreateAt(u int32) {
	if m.addcreate_at != nil {
		*m.addcreate_at += u
	} else {
		m.addcreate_at = &u
	}
}

// AddedCreateAt returns the value that was added to the "create_at" field in this mutation.
func (m *AppUserMutation) AddedCreateAt() (r int32, exists bool) {
	v := m.addcreate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *AppUserMutation) ResetCreateAt() {
	m.create_at = nil
	m.addcreate_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *AppUserMutation) SetUpdateAt(u uint32) {
	m.update_at = &u
	m.addupdate_at = nil
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *AppUserMutation) UpdateAt() (r uint32, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldUpdateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds u to the "update_at" field.
func (m *AppUserMutation) AddUpdateAt(u int32) {
	if m.addupdate_at != nil {
		*m.addupdate_at += u
	} else {
		m.addupdate_at = &u
	}
}

// AddedUpdateAt returns the value that was added to the "update_at" field in this mutation.
func (m *AppUserMutation) AddedUpdateAt() (r int32, exists bool) {
	v := m.addupdate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *AppUserMutation) ResetUpdateAt() {
	m.update_at = nil
	m.addupdate_at = nil
}

// SetDeleteAt sets the "delete_at" field.
func (m *AppUserMutation) SetDeleteAt(u uint32) {
	m.delete_at = &u
	m.adddelete_at = nil
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *AppUserMutation) DeleteAt() (r uint32, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldDeleteAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// AddDeleteAt adds u to the "delete_at" field.
func (m *AppUserMutation) AddDeleteAt(u int32) {
	if m.adddelete_at != nil {
		*m.adddelete_at += u
	} else {
		m.adddelete_at = &u
	}
}

// AddedDeleteAt returns the value that was added to the "delete_at" field in this mutation.
func (m *AppUserMutation) AddedDeleteAt() (r int32, exists bool) {
	v := m.adddelete_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *AppUserMutation) ResetDeleteAt() {
	m.delete_at = nil
	m.adddelete_at = nil
}

// Where appends a list predicates to the AppUserMutation builder.
func (m *AppUserMutation) Where(ps ...predicate.AppUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUser).
func (m *AppUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.app_id != nil {
		fields = append(fields, appuser.FieldAppID)
	}
	if m.email_address != nil {
		fields = append(fields, appuser.FieldEmailAddress)
	}
	if m.phone_no != nil {
		fields = append(fields, appuser.FieldPhoneNo)
	}
	if m.import_from_app != nil {
		fields = append(fields, appuser.FieldImportFromApp)
	}
	if m.create_at != nil {
		fields = append(fields, appuser.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, appuser.FieldUpdateAt)
	}
	if m.delete_at != nil {
		fields = append(fields, appuser.FieldDeleteAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appuser.FieldAppID:
		return m.AppID()
	case appuser.FieldEmailAddress:
		return m.EmailAddress()
	case appuser.FieldPhoneNo:
		return m.PhoneNo()
	case appuser.FieldImportFromApp:
		return m.ImportFromApp()
	case appuser.FieldCreateAt:
		return m.CreateAt()
	case appuser.FieldUpdateAt:
		return m.UpdateAt()
	case appuser.FieldDeleteAt:
		return m.DeleteAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appuser.FieldAppID:
		return m.OldAppID(ctx)
	case appuser.FieldEmailAddress:
		return m.OldEmailAddress(ctx)
	case appuser.FieldPhoneNo:
		return m.OldPhoneNo(ctx)
	case appuser.FieldImportFromApp:
		return m.OldImportFromApp(ctx)
	case appuser.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case appuser.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case appuser.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appuser.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appuser.FieldEmailAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailAddress(v)
		return nil
	case appuser.FieldPhoneNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNo(v)
		return nil
	case appuser.FieldImportFromApp:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportFromApp(v)
		return nil
	case appuser.FieldCreateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case appuser.FieldUpdateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case appuser.FieldDeleteAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_at != nil {
		fields = append(fields, appuser.FieldCreateAt)
	}
	if m.addupdate_at != nil {
		fields = append(fields, appuser.FieldUpdateAt)
	}
	if m.adddelete_at != nil {
		fields = append(fields, appuser.FieldDeleteAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appuser.FieldCreateAt:
		return m.AddedCreateAt()
	case appuser.FieldUpdateAt:
		return m.AddedUpdateAt()
	case appuser.FieldDeleteAt:
		return m.AddedDeleteAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appuser.FieldCreateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case appuser.FieldUpdateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	case appuser.FieldDeleteAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserMutation) ResetField(name string) error {
	switch name {
	case appuser.FieldAppID:
		m.ResetAppID()
		return nil
	case appuser.FieldEmailAddress:
		m.ResetEmailAddress()
		return nil
	case appuser.FieldPhoneNo:
		m.ResetPhoneNo()
		return nil
	case appuser.FieldImportFromApp:
		m.ResetImportFromApp()
		return nil
	case appuser.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case appuser.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case appuser.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	}
	return fmt.Errorf("unknown AppUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUser edge %s", name)
}

// AppUserExtraMutation represents an operation that mutates the AppUserExtra nodes in the graph.
type AppUserExtraMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	app_id         *uuid.UUID
	user_id        *uuid.UUID
	username       *string
	address_fields *[]string
	gender         *string
	postal_code    *string
	age            *uint32
	addage         *int32
	birthday       *uint32
	addbirthday    *int32
	avatar         *string
	_Organization  *string
	create_at      *uint32
	addcreate_at   *int32
	update_at      *uint32
	addupdate_at   *int32
	delete_at      *uint32
	adddelete_at   *int32
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AppUserExtra, error)
	predicates     []predicate.AppUserExtra
}

var _ ent.Mutation = (*AppUserExtraMutation)(nil)

// appuserextraOption allows management of the mutation configuration using functional options.
type appuserextraOption func(*AppUserExtraMutation)

// newAppUserExtraMutation creates new mutation for the AppUserExtra entity.
func newAppUserExtraMutation(c config, op Op, opts ...appuserextraOption) *AppUserExtraMutation {
	m := &AppUserExtraMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserExtra,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserExtraID sets the ID field of the mutation.
func withAppUserExtraID(id uuid.UUID) appuserextraOption {
	return func(m *AppUserExtraMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserExtra
		)
		m.oldValue = func(ctx context.Context) (*AppUserExtra, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserExtra.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserExtra sets the old AppUserExtra of the mutation.
func withAppUserExtra(node *AppUserExtra) appuserextraOption {
	return func(m *AppUserExtraMutation) {
		m.oldValue = func(context.Context) (*AppUserExtra, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserExtraMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserExtraMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserExtra entities.
func (m *AppUserExtraMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserExtraMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserExtraMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUserExtra.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *AppUserExtraMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserExtraMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserExtraMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *AppUserExtraMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserExtraMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserExtraMutation) ResetUserID() {
	m.user_id = nil
}

// SetUsername sets the "username" field.
func (m *AppUserExtraMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AppUserExtraMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AppUserExtraMutation) ResetUsername() {
	m.username = nil
}

// SetAddressFields sets the "address_fields" field.
func (m *AppUserExtraMutation) SetAddressFields(s []string) {
	m.address_fields = &s
}

// AddressFields returns the value of the "address_fields" field in the mutation.
func (m *AppUserExtraMutation) AddressFields() (r []string, exists bool) {
	v := m.address_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressFields returns the old "address_fields" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAddressFields(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressFields: %w", err)
	}
	return oldValue.AddressFields, nil
}

// ResetAddressFields resets all changes to the "address_fields" field.
func (m *AppUserExtraMutation) ResetAddressFields() {
	m.address_fields = nil
}

// SetGender sets the "gender" field.
func (m *AppUserExtraMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *AppUserExtraMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *AppUserExtraMutation) ResetGender() {
	m.gender = nil
}

// SetPostalCode sets the "postal_code" field.
func (m *AppUserExtraMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *AppUserExtraMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *AppUserExtraMutation) ResetPostalCode() {
	m.postal_code = nil
}

// SetAge sets the "age" field.
func (m *AppUserExtraMutation) SetAge(u uint32) {
	m.age = &u
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *AppUserExtraMutation) Age() (r uint32, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAge(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds u to the "age" field.
func (m *AppUserExtraMutation) AddAge(u int32) {
	if m.addage != nil {
		*m.addage += u
	} else {
		m.addage = &u
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *AppUserExtraMutation) AddedAge() (r int32, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *AppUserExtraMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetBirthday sets the "birthday" field.
func (m *AppUserExtraMutation) SetBirthday(u uint32) {
	m.birthday = &u
	m.addbirthday = nil
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *AppUserExtraMutation) Birthday() (r uint32, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldBirthday(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// AddBirthday adds u to the "birthday" field.
func (m *AppUserExtraMutation) AddBirthday(u int32) {
	if m.addbirthday != nil {
		*m.addbirthday += u
	} else {
		m.addbirthday = &u
	}
}

// AddedBirthday returns the value that was added to the "birthday" field in this mutation.
func (m *AppUserExtraMutation) AddedBirthday() (r int32, exists bool) {
	v := m.addbirthday
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *AppUserExtraMutation) ResetBirthday() {
	m.birthday = nil
	m.addbirthday = nil
}

// SetAvatar sets the "avatar" field.
func (m *AppUserExtraMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *AppUserExtraMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *AppUserExtraMutation) ResetAvatar() {
	m.avatar = nil
}

// SetOrganization sets the "Organization" field.
func (m *AppUserExtraMutation) SetOrganization(s string) {
	m._Organization = &s
}

// Organization returns the value of the "Organization" field in the mutation.
func (m *AppUserExtraMutation) Organization() (r string, exists bool) {
	v := m._Organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "Organization" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ResetOrganization resets all changes to the "Organization" field.
func (m *AppUserExtraMutation) ResetOrganization() {
	m._Organization = nil
}

// SetCreateAt sets the "create_at" field.
func (m *AppUserExtraMutation) SetCreateAt(u uint32) {
	m.create_at = &u
	m.addcreate_at = nil
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *AppUserExtraMutation) CreateAt() (r uint32, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldCreateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds u to the "create_at" field.
func (m *AppUserExtraMutation) AddCreateAt(u int32) {
	if m.addcreate_at != nil {
		*m.addcreate_at += u
	} else {
		m.addcreate_at = &u
	}
}

// AddedCreateAt returns the value that was added to the "create_at" field in this mutation.
func (m *AppUserExtraMutation) AddedCreateAt() (r int32, exists bool) {
	v := m.addcreate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *AppUserExtraMutation) ResetCreateAt() {
	m.create_at = nil
	m.addcreate_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *AppUserExtraMutation) SetUpdateAt(u uint32) {
	m.update_at = &u
	m.addupdate_at = nil
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *AppUserExtraMutation) UpdateAt() (r uint32, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldUpdateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds u to the "update_at" field.
func (m *AppUserExtraMutation) AddUpdateAt(u int32) {
	if m.addupdate_at != nil {
		*m.addupdate_at += u
	} else {
		m.addupdate_at = &u
	}
}

// AddedUpdateAt returns the value that was added to the "update_at" field in this mutation.
func (m *AppUserExtraMutation) AddedUpdateAt() (r int32, exists bool) {
	v := m.addupdate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *AppUserExtraMutation) ResetUpdateAt() {
	m.update_at = nil
	m.addupdate_at = nil
}

// SetDeleteAt sets the "delete_at" field.
func (m *AppUserExtraMutation) SetDeleteAt(u uint32) {
	m.delete_at = &u
	m.adddelete_at = nil
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *AppUserExtraMutation) DeleteAt() (r uint32, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldDeleteAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// AddDeleteAt adds u to the "delete_at" field.
func (m *AppUserExtraMutation) AddDeleteAt(u int32) {
	if m.adddelete_at != nil {
		*m.adddelete_at += u
	} else {
		m.adddelete_at = &u
	}
}

// AddedDeleteAt returns the value that was added to the "delete_at" field in this mutation.
func (m *AppUserExtraMutation) AddedDeleteAt() (r int32, exists bool) {
	v := m.adddelete_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *AppUserExtraMutation) ResetDeleteAt() {
	m.delete_at = nil
	m.adddelete_at = nil
}

// Where appends a list predicates to the AppUserExtraMutation builder.
func (m *AppUserExtraMutation) Where(ps ...predicate.AppUserExtra) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserExtraMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUserExtra).
func (m *AppUserExtraMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserExtraMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.app_id != nil {
		fields = append(fields, appuserextra.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, appuserextra.FieldUserID)
	}
	if m.username != nil {
		fields = append(fields, appuserextra.FieldUsername)
	}
	if m.address_fields != nil {
		fields = append(fields, appuserextra.FieldAddressFields)
	}
	if m.gender != nil {
		fields = append(fields, appuserextra.FieldGender)
	}
	if m.postal_code != nil {
		fields = append(fields, appuserextra.FieldPostalCode)
	}
	if m.age != nil {
		fields = append(fields, appuserextra.FieldAge)
	}
	if m.birthday != nil {
		fields = append(fields, appuserextra.FieldBirthday)
	}
	if m.avatar != nil {
		fields = append(fields, appuserextra.FieldAvatar)
	}
	if m._Organization != nil {
		fields = append(fields, appuserextra.FieldOrganization)
	}
	if m.create_at != nil {
		fields = append(fields, appuserextra.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, appuserextra.FieldUpdateAt)
	}
	if m.delete_at != nil {
		fields = append(fields, appuserextra.FieldDeleteAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserExtraMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appuserextra.FieldAppID:
		return m.AppID()
	case appuserextra.FieldUserID:
		return m.UserID()
	case appuserextra.FieldUsername:
		return m.Username()
	case appuserextra.FieldAddressFields:
		return m.AddressFields()
	case appuserextra.FieldGender:
		return m.Gender()
	case appuserextra.FieldPostalCode:
		return m.PostalCode()
	case appuserextra.FieldAge:
		return m.Age()
	case appuserextra.FieldBirthday:
		return m.Birthday()
	case appuserextra.FieldAvatar:
		return m.Avatar()
	case appuserextra.FieldOrganization:
		return m.Organization()
	case appuserextra.FieldCreateAt:
		return m.CreateAt()
	case appuserextra.FieldUpdateAt:
		return m.UpdateAt()
	case appuserextra.FieldDeleteAt:
		return m.DeleteAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserExtraMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appuserextra.FieldAppID:
		return m.OldAppID(ctx)
	case appuserextra.FieldUserID:
		return m.OldUserID(ctx)
	case appuserextra.FieldUsername:
		return m.OldUsername(ctx)
	case appuserextra.FieldAddressFields:
		return m.OldAddressFields(ctx)
	case appuserextra.FieldGender:
		return m.OldGender(ctx)
	case appuserextra.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case appuserextra.FieldAge:
		return m.OldAge(ctx)
	case appuserextra.FieldBirthday:
		return m.OldBirthday(ctx)
	case appuserextra.FieldAvatar:
		return m.OldAvatar(ctx)
	case appuserextra.FieldOrganization:
		return m.OldOrganization(ctx)
	case appuserextra.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case appuserextra.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case appuserextra.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserExtra field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserExtraMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appuserextra.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appuserextra.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appuserextra.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case appuserextra.FieldAddressFields:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressFields(v)
		return nil
	case appuserextra.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case appuserextra.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case appuserextra.FieldAge:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case appuserextra.FieldBirthday:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case appuserextra.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case appuserextra.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case appuserextra.FieldCreateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case appuserextra.FieldUpdateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case appuserextra.FieldDeleteAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserExtra field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserExtraMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, appuserextra.FieldAge)
	}
	if m.addbirthday != nil {
		fields = append(fields, appuserextra.FieldBirthday)
	}
	if m.addcreate_at != nil {
		fields = append(fields, appuserextra.FieldCreateAt)
	}
	if m.addupdate_at != nil {
		fields = append(fields, appuserextra.FieldUpdateAt)
	}
	if m.adddelete_at != nil {
		fields = append(fields, appuserextra.FieldDeleteAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserExtraMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appuserextra.FieldAge:
		return m.AddedAge()
	case appuserextra.FieldBirthday:
		return m.AddedBirthday()
	case appuserextra.FieldCreateAt:
		return m.AddedCreateAt()
	case appuserextra.FieldUpdateAt:
		return m.AddedUpdateAt()
	case appuserextra.FieldDeleteAt:
		return m.AddedDeleteAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserExtraMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appuserextra.FieldAge:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case appuserextra.FieldBirthday:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthday(v)
		return nil
	case appuserextra.FieldCreateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case appuserextra.FieldUpdateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	case appuserextra.FieldDeleteAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserExtra numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserExtraMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserExtraMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserExtraMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppUserExtra nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserExtraMutation) ResetField(name string) error {
	switch name {
	case appuserextra.FieldAppID:
		m.ResetAppID()
		return nil
	case appuserextra.FieldUserID:
		m.ResetUserID()
		return nil
	case appuserextra.FieldUsername:
		m.ResetUsername()
		return nil
	case appuserextra.FieldAddressFields:
		m.ResetAddressFields()
		return nil
	case appuserextra.FieldGender:
		m.ResetGender()
		return nil
	case appuserextra.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case appuserextra.FieldAge:
		m.ResetAge()
		return nil
	case appuserextra.FieldBirthday:
		m.ResetBirthday()
		return nil
	case appuserextra.FieldAvatar:
		m.ResetAvatar()
		return nil
	case appuserextra.FieldOrganization:
		m.ResetOrganization()
		return nil
	case appuserextra.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case appuserextra.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case appuserextra.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	}
	return fmt.Errorf("unknown AppUserExtra field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserExtraMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserExtraMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserExtraMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserExtraMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserExtraMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserExtraMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserExtraMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUserExtra unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserExtraMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUserExtra edge %s", name)
}

// AppUserSecretMutation represents an operation that mutates the AppUserSecret nodes in the graph.
type AppUserSecretMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	password_hash *string
	salt          *string
	google_secret *string
	create_at     *uint32
	addcreate_at  *int32
	update_at     *uint32
	addupdate_at  *int32
	delete_at     *uint32
	adddelete_at  *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppUserSecret, error)
	predicates    []predicate.AppUserSecret
}

var _ ent.Mutation = (*AppUserSecretMutation)(nil)

// appusersecretOption allows management of the mutation configuration using functional options.
type appusersecretOption func(*AppUserSecretMutation)

// newAppUserSecretMutation creates new mutation for the AppUserSecret entity.
func newAppUserSecretMutation(c config, op Op, opts ...appusersecretOption) *AppUserSecretMutation {
	m := &AppUserSecretMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserSecretID sets the ID field of the mutation.
func withAppUserSecretID(id uuid.UUID) appusersecretOption {
	return func(m *AppUserSecretMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserSecret
		)
		m.oldValue = func(ctx context.Context) (*AppUserSecret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserSecret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserSecret sets the old AppUserSecret of the mutation.
func withAppUserSecret(node *AppUserSecret) appusersecretOption {
	return func(m *AppUserSecretMutation) {
		m.oldValue = func(context.Context) (*AppUserSecret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserSecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserSecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserSecret entities.
func (m *AppUserSecretMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserSecretMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserSecretMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUserSecret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *AppUserSecretMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserSecretMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserSecretMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *AppUserSecretMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserSecretMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserSecretMutation) ResetUserID() {
	m.user_id = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *AppUserSecretMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *AppUserSecretMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *AppUserSecretMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetSalt sets the "salt" field.
func (m *AppUserSecretMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *AppUserSecretMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt resets all changes to the "salt" field.
func (m *AppUserSecretMutation) ResetSalt() {
	m.salt = nil
}

// SetGoogleSecret sets the "google_secret" field.
func (m *AppUserSecretMutation) SetGoogleSecret(s string) {
	m.google_secret = &s
}

// GoogleSecret returns the value of the "google_secret" field in the mutation.
func (m *AppUserSecretMutation) GoogleSecret() (r string, exists bool) {
	v := m.google_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleSecret returns the old "google_secret" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldGoogleSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleSecret: %w", err)
	}
	return oldValue.GoogleSecret, nil
}

// ResetGoogleSecret resets all changes to the "google_secret" field.
func (m *AppUserSecretMutation) ResetGoogleSecret() {
	m.google_secret = nil
}

// SetCreateAt sets the "create_at" field.
func (m *AppUserSecretMutation) SetCreateAt(u uint32) {
	m.create_at = &u
	m.addcreate_at = nil
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *AppUserSecretMutation) CreateAt() (r uint32, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldCreateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds u to the "create_at" field.
func (m *AppUserSecretMutation) AddCreateAt(u int32) {
	if m.addcreate_at != nil {
		*m.addcreate_at += u
	} else {
		m.addcreate_at = &u
	}
}

// AddedCreateAt returns the value that was added to the "create_at" field in this mutation.
func (m *AppUserSecretMutation) AddedCreateAt() (r int32, exists bool) {
	v := m.addcreate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *AppUserSecretMutation) ResetCreateAt() {
	m.create_at = nil
	m.addcreate_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *AppUserSecretMutation) SetUpdateAt(u uint32) {
	m.update_at = &u
	m.addupdate_at = nil
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *AppUserSecretMutation) UpdateAt() (r uint32, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldUpdateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds u to the "update_at" field.
func (m *AppUserSecretMutation) AddUpdateAt(u int32) {
	if m.addupdate_at != nil {
		*m.addupdate_at += u
	} else {
		m.addupdate_at = &u
	}
}

// AddedUpdateAt returns the value that was added to the "update_at" field in this mutation.
func (m *AppUserSecretMutation) AddedUpdateAt() (r int32, exists bool) {
	v := m.addupdate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *AppUserSecretMutation) ResetUpdateAt() {
	m.update_at = nil
	m.addupdate_at = nil
}

// SetDeleteAt sets the "delete_at" field.
func (m *AppUserSecretMutation) SetDeleteAt(u uint32) {
	m.delete_at = &u
	m.adddelete_at = nil
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *AppUserSecretMutation) DeleteAt() (r uint32, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldDeleteAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// AddDeleteAt adds u to the "delete_at" field.
func (m *AppUserSecretMutation) AddDeleteAt(u int32) {
	if m.adddelete_at != nil {
		*m.adddelete_at += u
	} else {
		m.adddelete_at = &u
	}
}

// AddedDeleteAt returns the value that was added to the "delete_at" field in this mutation.
func (m *AppUserSecretMutation) AddedDeleteAt() (r int32, exists bool) {
	v := m.adddelete_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *AppUserSecretMutation) ResetDeleteAt() {
	m.delete_at = nil
	m.adddelete_at = nil
}

// Where appends a list predicates to the AppUserSecretMutation builder.
func (m *AppUserSecretMutation) Where(ps ...predicate.AppUserSecret) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserSecretMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUserSecret).
func (m *AppUserSecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserSecretMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.app_id != nil {
		fields = append(fields, appusersecret.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, appusersecret.FieldUserID)
	}
	if m.password_hash != nil {
		fields = append(fields, appusersecret.FieldPasswordHash)
	}
	if m.salt != nil {
		fields = append(fields, appusersecret.FieldSalt)
	}
	if m.google_secret != nil {
		fields = append(fields, appusersecret.FieldGoogleSecret)
	}
	if m.create_at != nil {
		fields = append(fields, appusersecret.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, appusersecret.FieldUpdateAt)
	}
	if m.delete_at != nil {
		fields = append(fields, appusersecret.FieldDeleteAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserSecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appusersecret.FieldAppID:
		return m.AppID()
	case appusersecret.FieldUserID:
		return m.UserID()
	case appusersecret.FieldPasswordHash:
		return m.PasswordHash()
	case appusersecret.FieldSalt:
		return m.Salt()
	case appusersecret.FieldGoogleSecret:
		return m.GoogleSecret()
	case appusersecret.FieldCreateAt:
		return m.CreateAt()
	case appusersecret.FieldUpdateAt:
		return m.UpdateAt()
	case appusersecret.FieldDeleteAt:
		return m.DeleteAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserSecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appusersecret.FieldAppID:
		return m.OldAppID(ctx)
	case appusersecret.FieldUserID:
		return m.OldUserID(ctx)
	case appusersecret.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case appusersecret.FieldSalt:
		return m.OldSalt(ctx)
	case appusersecret.FieldGoogleSecret:
		return m.OldGoogleSecret(ctx)
	case appusersecret.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case appusersecret.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case appusersecret.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserSecret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserSecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appusersecret.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appusersecret.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appusersecret.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case appusersecret.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case appusersecret.FieldGoogleSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleSecret(v)
		return nil
	case appusersecret.FieldCreateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case appusersecret.FieldUpdateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case appusersecret.FieldDeleteAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserSecret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserSecretMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_at != nil {
		fields = append(fields, appusersecret.FieldCreateAt)
	}
	if m.addupdate_at != nil {
		fields = append(fields, appusersecret.FieldUpdateAt)
	}
	if m.adddelete_at != nil {
		fields = append(fields, appusersecret.FieldDeleteAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserSecretMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appusersecret.FieldCreateAt:
		return m.AddedCreateAt()
	case appusersecret.FieldUpdateAt:
		return m.AddedUpdateAt()
	case appusersecret.FieldDeleteAt:
		return m.AddedDeleteAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserSecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appusersecret.FieldCreateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case appusersecret.FieldUpdateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	case appusersecret.FieldDeleteAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserSecret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserSecretMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserSecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserSecretMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppUserSecret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserSecretMutation) ResetField(name string) error {
	switch name {
	case appusersecret.FieldAppID:
		m.ResetAppID()
		return nil
	case appusersecret.FieldUserID:
		m.ResetUserID()
		return nil
	case appusersecret.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case appusersecret.FieldSalt:
		m.ResetSalt()
		return nil
	case appusersecret.FieldGoogleSecret:
		m.ResetGoogleSecret()
		return nil
	case appusersecret.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case appusersecret.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case appusersecret.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	}
	return fmt.Errorf("unknown AppUserSecret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserSecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserSecretMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserSecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserSecretMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserSecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserSecretMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserSecretMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUserSecret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserSecretMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUserSecret edge %s", name)
}

// BanAppMutation represents an operation that mutates the BanApp nodes in the graph.
type BanAppMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	app_id        *uuid.UUID
	create_at     *uint32
	addcreate_at  *int32
	update_at     *uint32
	addupdate_at  *int32
	delete_at     *uint32
	adddelete_at  *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BanApp, error)
	predicates    []predicate.BanApp
}

var _ ent.Mutation = (*BanAppMutation)(nil)

// banappOption allows management of the mutation configuration using functional options.
type banappOption func(*BanAppMutation)

// newBanAppMutation creates new mutation for the BanApp entity.
func newBanAppMutation(c config, op Op, opts ...banappOption) *BanAppMutation {
	m := &BanAppMutation{
		config:        c,
		op:            op,
		typ:           TypeBanApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBanAppID sets the ID field of the mutation.
func withBanAppID(id uuid.UUID) banappOption {
	return func(m *BanAppMutation) {
		var (
			err   error
			once  sync.Once
			value *BanApp
		)
		m.oldValue = func(ctx context.Context) (*BanApp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BanApp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanApp sets the old BanApp of the mutation.
func withBanApp(node *BanApp) banappOption {
	return func(m *BanAppMutation) {
		m.oldValue = func(context.Context) (*BanApp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BanAppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BanAppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BanApp entities.
func (m *BanAppMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BanAppMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BanAppMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BanApp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *BanAppMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *BanAppMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *BanAppMutation) ResetAppID() {
	m.app_id = nil
}

// SetCreateAt sets the "create_at" field.
func (m *BanAppMutation) SetCreateAt(u uint32) {
	m.create_at = &u
	m.addcreate_at = nil
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *BanAppMutation) CreateAt() (r uint32, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldCreateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds u to the "create_at" field.
func (m *BanAppMutation) AddCreateAt(u int32) {
	if m.addcreate_at != nil {
		*m.addcreate_at += u
	} else {
		m.addcreate_at = &u
	}
}

// AddedCreateAt returns the value that was added to the "create_at" field in this mutation.
func (m *BanAppMutation) AddedCreateAt() (r int32, exists bool) {
	v := m.addcreate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *BanAppMutation) ResetCreateAt() {
	m.create_at = nil
	m.addcreate_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *BanAppMutation) SetUpdateAt(u uint32) {
	m.update_at = &u
	m.addupdate_at = nil
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *BanAppMutation) UpdateAt() (r uint32, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldUpdateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds u to the "update_at" field.
func (m *BanAppMutation) AddUpdateAt(u int32) {
	if m.addupdate_at != nil {
		*m.addupdate_at += u
	} else {
		m.addupdate_at = &u
	}
}

// AddedUpdateAt returns the value that was added to the "update_at" field in this mutation.
func (m *BanAppMutation) AddedUpdateAt() (r int32, exists bool) {
	v := m.addupdate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *BanAppMutation) ResetUpdateAt() {
	m.update_at = nil
	m.addupdate_at = nil
}

// SetDeleteAt sets the "delete_at" field.
func (m *BanAppMutation) SetDeleteAt(u uint32) {
	m.delete_at = &u
	m.adddelete_at = nil
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *BanAppMutation) DeleteAt() (r uint32, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldDeleteAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// AddDeleteAt adds u to the "delete_at" field.
func (m *BanAppMutation) AddDeleteAt(u int32) {
	if m.adddelete_at != nil {
		*m.adddelete_at += u
	} else {
		m.adddelete_at = &u
	}
}

// AddedDeleteAt returns the value that was added to the "delete_at" field in this mutation.
func (m *BanAppMutation) AddedDeleteAt() (r int32, exists bool) {
	v := m.adddelete_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *BanAppMutation) ResetDeleteAt() {
	m.delete_at = nil
	m.adddelete_at = nil
}

// Where appends a list predicates to the BanAppMutation builder.
func (m *BanAppMutation) Where(ps ...predicate.BanApp) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BanAppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BanApp).
func (m *BanAppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BanAppMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.app_id != nil {
		fields = append(fields, banapp.FieldAppID)
	}
	if m.create_at != nil {
		fields = append(fields, banapp.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, banapp.FieldUpdateAt)
	}
	if m.delete_at != nil {
		fields = append(fields, banapp.FieldDeleteAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BanAppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banapp.FieldAppID:
		return m.AppID()
	case banapp.FieldCreateAt:
		return m.CreateAt()
	case banapp.FieldUpdateAt:
		return m.UpdateAt()
	case banapp.FieldDeleteAt:
		return m.DeleteAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BanAppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banapp.FieldAppID:
		return m.OldAppID(ctx)
	case banapp.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case banapp.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case banapp.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	}
	return nil, fmt.Errorf("unknown BanApp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banapp.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case banapp.FieldCreateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case banapp.FieldUpdateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case banapp.FieldDeleteAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown BanApp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BanAppMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_at != nil {
		fields = append(fields, banapp.FieldCreateAt)
	}
	if m.addupdate_at != nil {
		fields = append(fields, banapp.FieldUpdateAt)
	}
	if m.adddelete_at != nil {
		fields = append(fields, banapp.FieldDeleteAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BanAppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banapp.FieldCreateAt:
		return m.AddedCreateAt()
	case banapp.FieldUpdateAt:
		return m.AddedUpdateAt()
	case banapp.FieldDeleteAt:
		return m.AddedDeleteAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banapp.FieldCreateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case banapp.FieldUpdateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	case banapp.FieldDeleteAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown BanApp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BanAppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BanAppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BanAppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BanApp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BanAppMutation) ResetField(name string) error {
	switch name {
	case banapp.FieldAppID:
		m.ResetAppID()
		return nil
	case banapp.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case banapp.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case banapp.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	}
	return fmt.Errorf("unknown BanApp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BanAppMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BanAppMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BanAppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BanAppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BanAppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BanAppMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BanAppMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BanApp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BanAppMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BanApp edge %s", name)
}

// BanAppUserMutation represents an operation that mutates the BanAppUser nodes in the graph.
type BanAppUserMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	create_at     *uint32
	addcreate_at  *int32
	update_at     *uint32
	addupdate_at  *int32
	delete_at     *uint32
	adddelete_at  *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BanAppUser, error)
	predicates    []predicate.BanAppUser
}

var _ ent.Mutation = (*BanAppUserMutation)(nil)

// banappuserOption allows management of the mutation configuration using functional options.
type banappuserOption func(*BanAppUserMutation)

// newBanAppUserMutation creates new mutation for the BanAppUser entity.
func newBanAppUserMutation(c config, op Op, opts ...banappuserOption) *BanAppUserMutation {
	m := &BanAppUserMutation{
		config:        c,
		op:            op,
		typ:           TypeBanAppUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBanAppUserID sets the ID field of the mutation.
func withBanAppUserID(id uuid.UUID) banappuserOption {
	return func(m *BanAppUserMutation) {
		var (
			err   error
			once  sync.Once
			value *BanAppUser
		)
		m.oldValue = func(ctx context.Context) (*BanAppUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BanAppUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanAppUser sets the old BanAppUser of the mutation.
func withBanAppUser(node *BanAppUser) banappuserOption {
	return func(m *BanAppUserMutation) {
		m.oldValue = func(context.Context) (*BanAppUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BanAppUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BanAppUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BanAppUser entities.
func (m *BanAppUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BanAppUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BanAppUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BanAppUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *BanAppUserMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *BanAppUserMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *BanAppUserMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *BanAppUserMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BanAppUserMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BanAppUserMutation) ResetUserID() {
	m.user_id = nil
}

// SetCreateAt sets the "create_at" field.
func (m *BanAppUserMutation) SetCreateAt(u uint32) {
	m.create_at = &u
	m.addcreate_at = nil
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *BanAppUserMutation) CreateAt() (r uint32, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldCreateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds u to the "create_at" field.
func (m *BanAppUserMutation) AddCreateAt(u int32) {
	if m.addcreate_at != nil {
		*m.addcreate_at += u
	} else {
		m.addcreate_at = &u
	}
}

// AddedCreateAt returns the value that was added to the "create_at" field in this mutation.
func (m *BanAppUserMutation) AddedCreateAt() (r int32, exists bool) {
	v := m.addcreate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *BanAppUserMutation) ResetCreateAt() {
	m.create_at = nil
	m.addcreate_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *BanAppUserMutation) SetUpdateAt(u uint32) {
	m.update_at = &u
	m.addupdate_at = nil
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *BanAppUserMutation) UpdateAt() (r uint32, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldUpdateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds u to the "update_at" field.
func (m *BanAppUserMutation) AddUpdateAt(u int32) {
	if m.addupdate_at != nil {
		*m.addupdate_at += u
	} else {
		m.addupdate_at = &u
	}
}

// AddedUpdateAt returns the value that was added to the "update_at" field in this mutation.
func (m *BanAppUserMutation) AddedUpdateAt() (r int32, exists bool) {
	v := m.addupdate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *BanAppUserMutation) ResetUpdateAt() {
	m.update_at = nil
	m.addupdate_at = nil
}

// SetDeleteAt sets the "delete_at" field.
func (m *BanAppUserMutation) SetDeleteAt(u uint32) {
	m.delete_at = &u
	m.adddelete_at = nil
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *BanAppUserMutation) DeleteAt() (r uint32, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldDeleteAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// AddDeleteAt adds u to the "delete_at" field.
func (m *BanAppUserMutation) AddDeleteAt(u int32) {
	if m.adddelete_at != nil {
		*m.adddelete_at += u
	} else {
		m.adddelete_at = &u
	}
}

// AddedDeleteAt returns the value that was added to the "delete_at" field in this mutation.
func (m *BanAppUserMutation) AddedDeleteAt() (r int32, exists bool) {
	v := m.adddelete_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *BanAppUserMutation) ResetDeleteAt() {
	m.delete_at = nil
	m.adddelete_at = nil
}

// Where appends a list predicates to the BanAppUserMutation builder.
func (m *BanAppUserMutation) Where(ps ...predicate.BanAppUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BanAppUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BanAppUser).
func (m *BanAppUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BanAppUserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.app_id != nil {
		fields = append(fields, banappuser.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, banappuser.FieldUserID)
	}
	if m.create_at != nil {
		fields = append(fields, banappuser.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, banappuser.FieldUpdateAt)
	}
	if m.delete_at != nil {
		fields = append(fields, banappuser.FieldDeleteAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BanAppUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banappuser.FieldAppID:
		return m.AppID()
	case banappuser.FieldUserID:
		return m.UserID()
	case banappuser.FieldCreateAt:
		return m.CreateAt()
	case banappuser.FieldUpdateAt:
		return m.UpdateAt()
	case banappuser.FieldDeleteAt:
		return m.DeleteAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BanAppUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banappuser.FieldAppID:
		return m.OldAppID(ctx)
	case banappuser.FieldUserID:
		return m.OldUserID(ctx)
	case banappuser.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case banappuser.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case banappuser.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	}
	return nil, fmt.Errorf("unknown BanAppUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banappuser.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case banappuser.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case banappuser.FieldCreateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case banappuser.FieldUpdateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case banappuser.FieldDeleteAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown BanAppUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BanAppUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_at != nil {
		fields = append(fields, banappuser.FieldCreateAt)
	}
	if m.addupdate_at != nil {
		fields = append(fields, banappuser.FieldUpdateAt)
	}
	if m.adddelete_at != nil {
		fields = append(fields, banappuser.FieldDeleteAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BanAppUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banappuser.FieldCreateAt:
		return m.AddedCreateAt()
	case banappuser.FieldUpdateAt:
		return m.AddedUpdateAt()
	case banappuser.FieldDeleteAt:
		return m.AddedDeleteAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banappuser.FieldCreateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case banappuser.FieldUpdateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	case banappuser.FieldDeleteAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown BanAppUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BanAppUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BanAppUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BanAppUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BanAppUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BanAppUserMutation) ResetField(name string) error {
	switch name {
	case banappuser.FieldAppID:
		m.ResetAppID()
		return nil
	case banappuser.FieldUserID:
		m.ResetUserID()
		return nil
	case banappuser.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case banappuser.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case banappuser.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	}
	return fmt.Errorf("unknown BanAppUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BanAppUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BanAppUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BanAppUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BanAppUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BanAppUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BanAppUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BanAppUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BanAppUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BanAppUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BanAppUser edge %s", name)
}
